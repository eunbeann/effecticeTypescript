- 타입스크립트의 큰 그림을 이해하는 데 도움이 될 내용
    - 타입스크립트란?
    - 타입스크립트를 어떻게 여겨야 하는지?
    - 자바스크립트랑은 어떤 관계 인지?
    
- 자바스크립트와 타입스크립트의 관계는 필연적
    - 자바스크립트로 컴파일되며, 실행 역시 자바스크립트로 이루어지기 때문.

## 아이템1 .타입스크립트와 자바스크립트의 관계 이해하기

- 타입스크립트는 문법적으로도 자바스크립트의 상위 집합
    - js 프로그램에 문법 오류가 없다면, 유효한 타입스크립트 프로그램이라고 할 수 있음.
    - 자바스크립트 프로그램에 이슈 존재 시 타입 체커에게 지적당할 수 있음 : 문법의 유효성과 동작의 이슈는 독립적인 문제로 타입스크립트는 작성된 코드를 파싱하고 자바스크립트로 변환 가능함.

- 자바스크립트 파일이 .js 확장자를 사용하는 반면 타입스크립트 파일은 .ts 확장자를 사용함.
    - 그러나 이 둘이 완전이 다른 언어라는 것은 아님.
    - 앞서 말했 듯 타입스트립트는 자바스크립트의 상위 집합이므로 .js 코드는 이미 타입스크립트임. : .js ⇒ .ts 해도 문제 발생하지 않음
    
    ⇒     이는 자바스크립트 코드를 타입스크립트로 마이그레이션하는데에 이점이 됨. : 기존 크드를 그대로 유지하며 일부분에만 타입스크립트 적용 가능.
    
- 모든 자바스크립트 프로그램은 타입스크립트지만.
모든 타입스크립트는 자바스크립트가 아님.

- 타입스크립트지만 자바스크립트가 아닌 프로그램 존재
    - 타입스크립트가 타입을 명시하는 추가적인 문법을 가지기 때문
    
    ```tsx
    function greet(who:string) {
    	console.log('Hello', who);
    }
    ```
    
    - 자바스크립트를 구동하는 노드(Node) 같은 프로그램으로 앞의 코드 실행 시 요류 발생 ⇒ `: string` 이 타입 구문이기 때문

- `타입 추론`은  타입스크립트에서 중요한 부분
    - 툭정 변수가 문자열이라는 것을 알려주지 않아도, 타입스크립트는 초깃값으로 부터 타입을 추론함.
    
    ```tsx
    let city = 'new york city';
    console.log(city.toUppercase());
    
    // 'toUppercase 속성이 'string' 형식에 없습니다. toUpperCase 속성을 사용하시겠습니까?
    // 코드에는 타입 구문이 없지만 타입스크립트의 타입 체커는 문자를 찾아냄
    ```
    
- 타입 시스템의 목표 중 하나
    - 런타임에 오류를 발생시킬 코드를 미리 찾아 내는 것.
    : 타입스크립트가 ‘정적’ 타입 시스템이라는 특징
- 타입 스크립트는 타입 구문 없이도 오류를 잡을 수 있지만, 타입 구문을 추가한다면 훨씬 더 많은 오류를 찾아낼 수 있음.
- 코드와 오류가 무엇인지 **타입 구문을 통해 타입스크립트에게 알려줄 수 있으므로** 코드의 동작과 의도가 다른 부분을 찾을 수 있음.

- 타입 스크립트는 해결책을 제시하긴 하지만 이는 항상 정확하지 않음 `명시적으로 state를 선언하여 의도 분명히 하기`
    - 예시
        
        ```tsx
        interface State {
            name: string;
            capital: string;
        }
        const states: State[] = [
            {name : 'Alabama', capitol: 'Montgemry'},
            {name : 'Alaska', capitol: 'Juneau'},
            {name : 'Arizona', capitol: 'Phonenx'},
        ];
        
        for (const state of states ) {
            console.log(state.capital);
        }
        ```
        
        ```tsx
        개체 리터럴은 알려진 속성만 지정할 수 있지만 'State' 형식에 'capitol'이 없습니다. 
        capital'을 쓰려고 했습니가?
        ```
        
    - 오류 부분을 알 수 있고, 제시된 해결 책도 올바름
    - 의도를 면확히 해서 타입스크립트가 잠재적 문제점을 찾을 수 있게 한다
    
- 위 예시를 통해서 생각할 수 있는 점은
`모든 자바스크립트는 타입스크립트지만, 일부 자바스크립트(그리고 타입스크립트)만이 타입 체크를 통과함`

- 보통은 타입 체크에서 오류가 발생하지 않도록 신경 쓰며 타입스크립트를 작성함.

- 타입스크입트 타입 시스템은 자바스크립트의 런타임 동작을 모델링함. 따라서 타임 체커가 오류를 표시하기도 함. (capitol 예시)

> 타입스크립트의 도움을 받으면 오류가 적은 코드를 작성할 수 있음.
> 

<aside>
💡 타입스크립트는 자바스크립트의 상위집합으로 모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램
💡 타입스크립트는 런타임 동작을 모델링하는 대신 타입 시스템을 가지고 있어 런타임 오류 발생 코드를 찾아냄. 그러나 모든 오류를 찾는 것은 아님을 유념하기
💡 타입스크립트 타입 시스템은 전반적으로 자바스크립트 동작을 모델링함. 그렇지만 자바스크립트에서는 허용되지만 타입스크립트에서는 문제가 되는 경우가 있다는 것을 알고 있기

</aside>

## 아이템2. 타입스크립트 설정 이해하기

- 타입스크립트 설정에 따라서 코드의 타입 체커 통과 여부 결정됨

- 타입스크립트 설정은 커맨드 라인에서 설정 가능
    
    `$ tsc —noImplicitAny proram.ts`
    
- tsconfig.json 설정 파일을 통해서도 가능함
    
    ```tsx
    {
    	"CompilerOptions": {
    		"noImplicitAny": true
    	}
    }
    ```
    
- **가급적이면 설정 파일 사용하기**
    - 동료들 다른 도구들과 이해하기
    - tsc —init

- 타입스크립트의 설정
    - 소스 파일 경로, 출력 종류 제어가 대부분이지만
    - 언어 자체의 핵심 요소를 제어하기도 함.
    - noImplicitAny와 StrictNullCheck 이해하기
        - **noImplicitAny**
            - 변수들이 미리 정의된 타입을 가져야하는지 여부 제어
            - any 타입을 매개변수에 사용하면 타입 체커는 무의미해지므로 이를 사용하지 못하게 함
            - 타입스크립트는 타입 정보를 가질 때 가장 효과적이므로 설정 필요
                1. 타입스크립트의 문제 발견이 쉬워짐
                2. 코드의 가독성이 좋아짐
                3. 개발자의 생상선 향상
            - noImplicitAny의 설정해지는 : 자바스크립트로 되어 있는 기존 프로그램을 타입스크립트로 전환하는 과정에만 필요함
        - **StrictNullCheck**
            - null과 Undefined가 모든 타입에서 허용되는지 확인하는 설정
            - null과 Undefinded 관련 오류를 잡는 것엔 도움되지만 코드 작성은 어려워짐
                - 새 프로젝트 시작시에 설정하는 것은 좋지만, 타입스크립트를 처음 마주하거나, 자바스크립트를 마이그레이션 하는 중이라면 설정하지 않앋 괜찮음.
    - 공동 프로젝트 진행 중 타입스크립트 예제 전송에 오류가 재현되지 않ㅇ는다면, 컴파일러 설정이 동일한지를 먼저 확인해야 함.

<aside>
💡 요약
💡 타입스크립트 컴파일러는 언어의 핵심 요소에 영향을 미치는 몇 가지 설정을 포함함
💡타입스크립트 설정은 커맨드 라인을 이용하기 보다 tsconfig.json 사용하기
💡 자바스크립트 프로젝트를 타입스크립트로 전환하는 게 아닐 경우 noImplicitAny 설정하기
💡 ”undefinded”는 객체가 아닙니다 같은 런타임 오류 방지를 위해 strict NullChecks를 설정하는 것이 좋음
💡 타입스크립트에서 엄격한 체크를 하고 싶다면 strict 설정 고려

</aside>

## 아이템3. 코드 생성과 타입 관계 없음의 이해

- 타입스크립트 컴팡일러는 크게 두 가지 역할 수행
    1. 최신 타입스크립트 / 자바스크립트를 브라우저에서 동작할 수 있ㄷ로고 구버전의 자바스크립트를 트랜스파일함.
    2. 코드의 타입 오류 체크

→ 이 두 가지는 **완벽히 독립적**

→ 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않음
→ 그 자바스크립트의 실행 시점에도 타입은 영향을 미치지 않음.

### 타입 오류가 있는 코드도 컴파일 가능

- 컴파일과 타입 체크는 독립적이기 때문
    - 타입스크립트 오류는 warning과 비슷해서, 문제가 될 만한 부분을 알려주지만 빌드를 멈추지는 않음.

- 이 두 가지가 독립적이므로 문제된 오류 수정 없이도 애플리케이션의 다른 부분 테스트가 가능함.
- 오류가 있을 때 컴파일 하지 않으려면 
tsconfig.json에 `noEmitOnError`를 설정하거나 빌드 도구에 동일하게 적용하기.

### 런타임에는 타입 체크 불가

```tsx
interface Square {
    width: number;
}

 interface Rectangle extends Square {
    height: number;
 }

 type Shape = Square | Rectangle;

 function calculayeArea (shape: Shape) {
    if (shape instanceof Rectangle) {
        return shape.width * shape.height;
    } else {
        return shape.width * shape.width;
    }
 }
```

- instanceof 체크는 런타임에 일어나지만, Rectangle은 타입이므로 런타임 시점에 아무런 역할 불가
- 타입스크립트의 타입은 제거 가능하므로 실제 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 제거 됨
    - shape 타입을 명확하게 하려면 런타임에 타입 정보를 유지하는 방법이 필요함.
        1. height에 속성이 존재하는지 체크하기
        2. 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 ‘태그’ 기법 사용하기

### 타입 연산은 런타임에 영향을 주지 않음.

- 값을 정제하기 위해서는 (string, numer 을 모두 number로 받음) 런타입의 타입을 체크해야하고, 자바스크립트 연산을 통해 변환 수행 필요

```tsx
function asNumber(val: number | string) : number {
	return typeof(val) === 'string'? Number(val) : val; }
```

### 런타임 타입은 선언된 타입과 다를 수 있음.

- 타입스크립트의 타입이 (ex. :blooean) 런타임때는 제거되는 과정에서 일어날 수 있는일.
- 순수 타입스크립트에서 네트워크 호출로부터 받아온 값으로 함수를 실행함으로써 마지막 코드를 실행하는 방법도 존재
- 이런 혼란스러운 상황은 가능한 피해야하며, 선언된 타입이 언제든지 달라질 수 있음을 명심해야 함.

### 타입스크립트 타입으로는 함수를 오버로드 할 수 없음.

`함수 오버로딩` : 동일한 이름에 매개변수만 다른 버전의 함수를 허용하는 것 

- 타입스크립트에서는 타입과 런타임의 동작이 무관해 함수 오버로딩이 불가능함
- 타입스크립트가 함수 오버로딩 기능을 지원하긴 하지만, 온전이 타입 수준에서만 동작
    - 구현재(Implementation)은 오직 하나뿐임.

### 타입스크립트의 타입은 런타임 성능에 영향을 주지 않음

- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되므로 런타임의 성능에 아무런 영향을 주지 않음.
- 타입스크립트의 정적 타입은 실제로 비용 X

<aside>
💡 요약
💡:코드 생성은 타입 시스템과 무관해 타입스크립트의 타입은 런타임 동작 혹은 성능에 영향 주지 않음
💡 타입 오류가 있어도 컴파일 가능
💡 타입스크립트 타입은 런타임에 사용 불가능하며 이를 지정하기 위해서는 타입 정보 유지를 위한 별도의 방법이 필요함. 일반적으로는 태그된 유니온, 속성 체크 방법 사용.

</aside>

## 아이템 4. 구조적 타이핑에 익숙해지기

- 자바스크립트는 본질적으로 덕 타이핑 기반
    - 함수의 매개변수 값이 모두 주어졌다면 어떻게 만들어졌는지는 신경쓰지 않고 사용함.
- 타입스크립트는 이 방식을 그대로 모델링해 매개변수값이 요구 사항은 만족한다면 타입이 무엇인지 신경쓰지않음.

- 함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하지 쉬움
    - 이러한 타입은 “봉인된(sealed) 혹은 정확한(precise)’ 타입이라고 불리우며 타입스크립트 타입 시스템에서는 표현할 수 없음.

<aside>
💡 요약

- 자바스크립트가 덕 타이핑 기반이고, 타입스크립트는 이를 모델링하기 위해 구조적 타이핑을 사용함. 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성들을 가지고 있을 것임 → 타입은 봉인되어 있지 않음

 -클래스 역시 구조적 타이핑 규칙을 따름. 클래스의 인스턴스과 예상과 다를 수 있음

- 구조적 타이핑을 사용, 유닛 테스팅을 쉽게 진행 가능

</aside>

## 아이템5. any 타입 지정하기

- 타입 스크립트의 타입은 점진적이고 선택적임
    - 점진적 : 코드에 타입을 조금씩 추가 가능
    - 선택적 : 언제든지 타입 체커를 해제할 수 있음
    
    → 이 기능들의 핵심은 any 타입
    
- 특별한 경우를 제외하고는 any를 사용하면 타입스크립트의 장점을 누릴 수 없음.

### any 타입에는 타입 안정성이 없음.

- 타입 체커는 선언에 따라 임의로 판단하고 이에 대한 혼돈은 크게 작용하게 됨

### any는 함수 시그니처를 무시함.

- 함수 작성시에는 시그니처를 명시해야 함.
    - 호출하는 쪽은 약속된 타입의 입력을 제공하고
    함수는 약속된 타입의 출력을 반환
    ⇒ any 타입 사용시에는 이런 약속을 어기게 될 수 있음.

### any 타입에는 언어 서비스가 적용되지 않음

- 타입스크립트 언어 서비스는 자동완성 기능과 적절한 도움말을 제공 함.
    - any 타입인 심벌 사용시 아무런 도움도 받지 못함 ㅜ.ㅜ

- 타입스크립트의 모토는 확장 가능한 자바스크립트이지만 이를 통한 생산성 향상의 이득을 보지 못함

### any 타입은 코드 리펙토링시에 버그를 감춤.

### any는 타입 설계를 감춤

- 애플리케이션 상태 같은 객체를 정의하려면 꽤 복잡함.
- 상태 개게 안에 있는 수많은 속성의 타입을 일일이 작성해야하는데 any 타입에서는 쉽게 끝낼 수 있음.
    - 그럼에도 불구하고 사용하면 안 됨!!
    - 상태 객체의 설계를 감추기 때문에
    - 깔끔하고 명료한 코드 작성을 위해 제대로 된 타입 설계는 필수적.

### any는 타입시스템의 신뢰도를 떨어뜨림.

- 타입 체커가 실수를 잡아주고 코드의 신뢰도가 높아짐.
    - 런타임에 타입 오류를 발견하게 된다면 타입 체커 신뢰도가 없어짐.
    - 타입스크립트는 개발자 편하자고 쓰는건데 너무 남발하면 일이 더 어려워짐. 타입 오류를 고쳐야하고, 머리 속으로 실제 타입 정보를 기억하기도 해야함.

<aside>
💡 요약
💡any 타입 사용시 타입 체커와 타입 스크립트 언어 서비승를 무력화 시킴
💡  any 타입은 진짜 문제점을 감추면서 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어뜨리니 사용 피하기

</aside>